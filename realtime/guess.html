<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BTC 15-Min Outcome Guesser (ET)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
      background:#0a0e27;color:#e0e0e0;padding:20px;line-height:1.6
    }
    .container{max-width:1400px;margin:0 auto}
    h1{text-align:center;color:#4a9eff;margin-bottom:30px;font-size:28px}
    .header-section{background:#1a1f3a;border-radius:8px;padding:20px;margin-bottom:20px;border:1px solid #2a3f5f}
    .time-display{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-bottom:15px}
    .time-box{background:#0f1729;padding:12px;border-radius:6px;border:1px solid #2a3f5f}
    .time-box label{display:block;font-size:11px;color:#888;text-transform:uppercase;margin-bottom:5px}
    .time-box .value{font-size:18px;font-weight:600;color:#4a9eff}
    .countdown{font-size:24px!important;color:#ff6b6b}

    .main-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px}
    @media (max-width:1000px){.main-grid{grid-template-columns:1fr}}

    .card{background:#1a1f3a;border-radius:8px;padding:20px;border:1px solid #2a3f5f}
    .card h2{font-size:18px;margin-bottom:15px;color:#4a9eff;border-bottom:1px solid #2a3f5f;padding-bottom:10px}

    .prediction-display{text-align:center;padding:20px}
    .prediction-direction{font-size:48px;font-weight:700;margin-bottom:10px}
    .prediction-direction.UP{color:#51cf66}
    .prediction-direction.DOWN{color:#ff6b6b}
    .prediction-direction.FLAT{color:#ffd93d}
    .prediction-probability{font-size:24px;color:#888;margin-bottom:10px}
    .prediction-why{text-align:left;background:#0f1729;padding:15px;border-radius:6px;margin-top:15px}
    .prediction-why ul{list-style:none;padding-left:0}
    .prediction-why li{padding:5px 0;font-size:13px;color:#bbb}

    .provider-table{width:100%;border-collapse:collapse;font-size:13px}
    .provider-table th{background:#0f1729;padding:10px;text-align:left;color:#888;font-weight:600;border-bottom:1px solid #2a3f5f}
    .provider-table td{padding:10px;border-bottom:1px solid #2a3f5f}
    .provider-status{display:inline-block;padding:3px 8px;border-radius:3px;font-size:11px;font-weight:700}
    .provider-status.included{background:#51cf66;color:#000}
    .provider-status.excluded{background:#ff6b6b;color:#fff}
    .provider-status.error{background:#888;color:#fff}
    .provider-status.pending{background:#444;color:#fff}

    .chart-container{position:relative;height:250px;margin-top:15px}
    canvas{width:100%;height:100%;border-radius:6px;background:#0f1729}

    .history-table{width:100%;border-collapse:collapse;font-size:12px}
    .history-table th{
      background:#0f1729;padding:8px;text-align:left;color:#888;font-weight:600;border-bottom:1px solid #2a3f5f;
      cursor:pointer;position:sticky;top:0
    }
    .history-table th:hover{background:#1a2235}
    .history-table td{padding:8px;border-bottom:1px solid #2a3f5f}
    .history-container{max-height:400px;overflow-y:auto}

    .correct-mark{display:inline-block;width:16px;height:16px;border-radius:50%;text-align:center;line-height:16px;font-weight:800;font-size:11px}
    .correct-mark.yes{background:#51cf66;color:#000}
    .correct-mark.no{background:#ff6b6b;color:#fff}
    .correct-mark.pending{background:#888;color:#fff}

    .controls{display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap}
    button{
      background:#4a9eff;color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;
      font-size:13px;font-weight:700;transition:background .2s
    }
    button:hover{background:#357abd}
    button.danger{background:#ff6b6b}
    button.danger:hover{background:#cc5555}

    .warning{background:#ff922b;color:#000;padding:10px;border-radius:6px;margin-bottom:15px;font-size:13px;font-weight:800}
    .confidence-warning{
      background:#ffd93d;color:#000;padding:8px 12px;border-radius:6px;display:inline-block;font-size:11px;font-weight:900;margin-top:10px
    }

    .stats-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px;margin-top:15px}
    .stat-box{background:#0f1729;padding:12px;border-radius:6px;text-align:center}
    .stat-box label{display:block;font-size:11px;color:#888;margin-bottom:5px}
    .stat-box .value{font-size:20px;font-weight:800;color:#4a9eff}

    .debug-info{
      background:#1a1f3a;border:1px solid #ff6b6b;border-radius:6px;padding:10px;margin-bottom:20px;
      font-size:12px;font-family:monospace;color:#ff6b6b;display:none
    }
    .debug-info.show{display:block}
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö° BTC 15-Min Outcome Guesser (ET)</h1>

    <div id="debugInfo" class="debug-info"></div>

    <div class="header-section">
      <div class="time-display">
        <div class="time-box">
          <label>Current ET Time</label>
          <div class="value" id="currentTime">--:--:--</div>
        </div>
        <div class="time-box">
          <label>Window Start (ET)</label>
          <div class="value" id="windowStart">--:--:--</div>
        </div>
        <div class="time-box">
          <label>Window End (ET)</label>
          <div class="value" id="windowEnd">--:--:--</div>
        </div>
        <div class="time-box">
          <label>Time Until End</label>
          <div class="value countdown" id="countdown">--:--</div>
        </div>
      </div>

      <div class="stats-row">
        <div class="stat-box">
          <label>Total Windows</label>
          <div class="value" id="totalWindows">0</div>
        </div>
        <div class="stat-box">
          <label>Correct</label>
          <div class="value" id="correctCount">0</div>
        </div>
        <div class="stat-box">
          <label>Accuracy</label>
          <div class="value" id="accuracy">--%</div>
        </div>
      </div>
    </div>

    <div class="main-grid">
      <div class="card">
        <h2>Current Prediction</h2>
        <div id="predictionWarning"></div>
        <div class="prediction-display">
          <div class="prediction-direction" id="predictionDirection">LOADING...</div>
          <div class="prediction-probability" id="predictionProbability">---%</div>

          <!-- ‚úÖ Strong suggestion box -->
          <div id="tradeSuggestion" class="confidence-warning" style="display:none;"></div>
          <!-- ‚úÖ FINAL CALL (locked around T-8..T-7) -->
          <div id="finalCallBox" class="confidence-warning" style="display:none;"></div>

          <div class="prediction-why" id="predictionWhy">
            <strong>Why:</strong>
            <ul id="predictionReasons"></ul>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Price Providers</h2>
        <table class="provider-table">
          <thead>
            <tr>
              <th>Provider</th>
              <th>Price (USD)</th>
              <th>Latency</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody id="providerTableBody">
            <tr><td colspan="4">Loading...</td></tr>
          </tbody>
        </table>
        <div id="confidenceWarning"></div>
      </div>
    </div>

    <div class="card">
      <h2>Price Chart (Last 90 Minutes)</h2>
      <div class="chart-container">
        <canvas id="priceChart"></canvas>
      </div>
    </div>

    <div class="card">
      <h2>History</h2>
      <div class="controls">
        <button onclick="app.exportHistory()">üì• Export JSON</button>
        <button onclick="document.getElementById('importFile').click()">üì§ Import JSON</button>
        <button class="danger" onclick="app.clearHistory()">üóëÔ∏è Clear History</button>
        <input type="file" id="importFile" style="display:none" accept=".json" onchange="app.importHistory(event)">
      </div>
      <div class="history-container">
        <table class="history-table">
          <thead>
            <tr>
              <th onclick="app.sortHistory('timestamp')">Time ‚Üï</th>
              <th>Window</th>
              <th>Predicted</th>
              <th>Actual</th>
              <th>Entry</th>
              <th>Exit</th>
              <th>Correct</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
            <tr><td colspan="7">No history yet</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/* =========================
   DEBUG LOGGER
========================= */
const DebugLogger = {
  logs: [],
  add(message, type='info'){
    const timestamp = new Date().toLocaleTimeString();
    this.logs.push({timestamp, message, type});
    console.log(`[${timestamp}] ${message}`);
    this.render();
  },
  render(){
    const div = document.getElementById('debugInfo');
    if (this.logs.length > 0){
      div.classList.add('show');
      div.innerHTML = this.logs.slice(-6).map(l => `[${l.timestamp}] ${l.message}`).join('<br>');
    }
  }
};

/* =========================
   TIME UTILS (ET)
========================= */
const TimeUtils = {
  ET_TIMEZONE: 'America/New_York',

  getNowET(){ return new Date(); },

  formatET(date, format='full'){
    const options = format === 'full'
      ? {timeZone:this.ET_TIMEZONE, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false}
      : {timeZone:this.ET_TIMEZONE, hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false};
    return new Intl.DateTimeFormat('en-US', options).format(date);
  },

  get15MinWindowBoundaries(date){
    const etParts = new Intl.DateTimeFormat('en-US',{
      timeZone:this.ET_TIMEZONE, year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
    }).formatToParts(date);

    const parts = {};
    etParts.forEach(p => parts[p.type] = p.value);

    const minutes = parseInt(parts.minute,10);
    const flooredMinutes = Math.floor(minutes/15)*15;

    const startStr = `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${String(flooredMinutes).padStart(2,'0')}:00`;
    const startDate = this.parseETString(startStr);
    const endDate = new Date(startDate.getTime() + 15*60*1000);
    return {start:startDate, end:endDate};
  },

  parseETString(etString){
    const m = etString.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/);
    if (!m) return new Date(etString);

    const year=m[1], mo=m[2], day=m[3], hh=m[4], mm=m[5], ss=m[6];

    for (let offset=-12; offset<=12; offset++){
      const testDate = new Date(`${year}-${mo}-${day}T${hh}:${mm}:${ss}`);
      testDate.setHours(testDate.getHours() - offset);

      const etFormatter = new Intl.DateTimeFormat('en-US',{
        timeZone:this.ET_TIMEZONE, year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
      });
      const formatted = etFormatter.format(testDate).replace(/(\d+)\/(\d+)\/(\d+),/, '$3-$1-$2');
      if (formatted.includes(`${hh}:${mm}:${ss}`)) return testDate;
    }
    return new Date(etString);
  },

  formatCountdown(seconds){
    if (seconds < 0) return '00:00';
    const mins = Math.floor(seconds/60);
    const secs = seconds % 60;
    return `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
  }
};

/* =========================
   PROVIDERS + RATE LIMIT
========================= */
class BaseProvider {
  constructor(name){
    this.name = name;
    this.minInterval = 3000;
    this.lastFetchByKey = new Map();
    this.errorCount = 0;
    this.maxErrors = 5;
  }

  shouldSkip(){ return this.errorCount >= this.maxErrors; }

  async fetchWithRateLimit(url, options = {}){
    const key = options.rateKey || 'default';
    const now = Date.now();
    const last = this.lastFetchByKey.get(key) || 0;

    if (now - last < this.minInterval){
      throw new Error('Rate limit');
    }

    this.lastFetchByKey.set(key, now);
    const start = Date.now();

    try{
      DebugLogger.add(`Fetching ${this.name}(${key})`);
      const response = await fetch(url, {
        ...options,
        mode:'cors',
        headers: {
          'Accept':'application/json',
          ...(options.headers || {})
        }
      });

      if (!response.ok){
        const msg = `HTTP ${response.status}`;
        throw new Error(msg);
      }

      const data = await response.json();
      this.errorCount = 0;
      const latency = Date.now() - start;
      DebugLogger.add(`${this.name}(${key}) ok (${latency}ms)`);
      return {data, latency};
    } catch (err){
      this.errorCount++;
      DebugLogger.add(`${this.name}(${key}) error: ${err.message}`, 'error');
      throw err;
    }
  }
}

class BinanceProvider extends BaseProvider {
  constructor(){
    super('Binance');
    this.minInterval = 1200;
  }

  async getCurrentPrice(){
    if (this.shouldSkip()) throw new Error('Max errors reached');
    const url = 'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT';
    const {data, latency} = await this.fetchWithRateLimit(url, { rateKey:'price' });
    return {price: parseFloat(data.price), latency};
  }

  async getCandles(startTime, endTime){
    if (this.shouldSkip()) throw new Error('Max errors reached');
    const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&startTime=${startTime}&endTime=${endTime}&limit=1000`;
    const {data} = await this.fetchWithRateLimit(url, { rateKey:'candles' });

    const candles = data.map(c => ({
      timestamp: c[0],
      open: parseFloat(c[1]),
      high: parseFloat(c[2]),
      low: parseFloat(c[3]),
      close: parseFloat(c[4]),
      volume: parseFloat(c[5]),
    }));
    return {candles};
  }
}

class CoinbaseProvider extends BaseProvider {
  constructor() {
    super('Coinbase');
    this.minInterval = 3000;
  }

  async getCurrentPrice() {
    if (this.shouldSkip()) throw new Error('Max errors reached');
    const url = 'https://api.coinbase.com/v2/prices/BTC-USD/spot';
    const { data, latency } = await this.fetchWithRateLimit(url, { rateKey: 'price' });

    const price = parseFloat(data?.data?.amount);
    if (!Number.isFinite(price)) throw new Error('Bad price data');
    return { price, latency };
  }
}

class CoinGeckoProvider extends BaseProvider {
  constructor(){
    super('CoinGecko');
    this.minInterval = 15000;
  }

  async getCurrentPrice(){
    if (this.shouldSkip()) throw new Error('Max errors reached');
    const url = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd';
    const {data, latency} = await this.fetchWithRateLimit(url, { rateKey:'price' });
    return {price: data?.bitcoin?.usd ?? null, latency};
  }
}

/* =========================
   AGGREGATOR
========================= */
class PriceAggregator {
  constructor(){
    this.providers = [
      new BinanceProvider(),
      new CoinbaseProvider(),
      new CoinGeckoProvider(),
    ];
    this.outlierThreshold = 0.0035; // 0.35%
    this.lastCandles = [];
    this.lastCandlesAt = 0;
  }

  async fetchAllPrices(){
    const results = await Promise.allSettled(this.providers.map(p => p.getCurrentPrice()));
    const providerData = [];
    const prices = [];

    results.forEach((result, idx) => {
      const provider = this.providers[idx];
      if (result.status === 'fulfilled' && typeof result.value.price === 'number'){
        providerData.push({
          name: provider.name,
          price: result.value.price,
          latency: result.value.latency,
          status: 'pending'
        });
        prices.push(result.value.price);
      } else {
        providerData.push({
          name: provider.name,
          price: null,
          latency: null,
          status: 'error',
          error: result.status === 'rejected' ? (result.reason?.message || 'Error') : 'Bad data'
        });
      }
    });

    if (prices.length === 0){
      return { referencePrice: null, providerData, confidence: 'NO_DATA' };
    }

    const sortedPrices = [...prices].sort((a,b) => a-b);
    const median = sortedPrices[Math.floor(sortedPrices.length/2)];

    const validPrices = [];
    providerData.forEach(pd => {
      if (pd.price !== null){
        const deviation = Math.abs(pd.price - median) / median;
        if (deviation > this.outlierThreshold){
          pd.status = 'excluded';
        } else {
          pd.status = 'included';
          validPrices.push(pd.price);
        }
      }
    });

    let referencePrice = null;
    let confidence = 'NO_DATA';

    if (validPrices.length >= 2){
      const s = [...validPrices].sort((a,b)=>a-b);
      referencePrice = s[Math.floor(s.length/2)];
      confidence = 'HIGH';
    } else if (validPrices.length === 1){
      referencePrice = validPrices[0];
      confidence = 'LOW';
    }

    return { referencePrice, providerData, confidence };
  }

  async fetchCandles(startTime, endTime){
    const binance = this.providers.find(p => p instanceof BinanceProvider);
    if (!binance) return [];

    try{
      const res = await binance.getCandles(startTime, endTime);
      DebugLogger.add(`Candles: ${res.candles.length}`);
      this.lastCandles = res.candles;
      this.lastCandlesAt = Date.now();
      return res.candles;
    } catch (err){
      const ageMs = Date.now() - this.lastCandlesAt;
      if (this.lastCandles.length > 0 && ageMs < 120000){
        DebugLogger.add(`Candle fetch failed (${err.message}) -> using cached candles`);
        return this.lastCandles;
      }
      DebugLogger.add(`Candle fetch failed: ${err.message}`, 'error');
      return [];
    }
  }
}

/* =========================
   INDICATORS
========================= */
class Indicators {
  static calculateReturns(prices, period){
    if (prices.length < period + 1) return 0;
    const current = prices[prices.length-1];
    const past = prices[prices.length-1-period];
    return (current - past) / past;
  }
  static calculateSMA(prices, period){
    if (prices.length < period) return null;
    const slice = prices.slice(-period);
    return slice.reduce((a,b)=>a+b,0)/period;
  }
  static calculateVolatility(prices, period){
    if (prices.length < period + 1) return 0;
    const returns = [];
    for (let i = prices.length - period; i < prices.length; i++){
      const ret = (prices[i] - prices[i-1]) / prices[i-1];
      returns.push(ret);
    }
    const mean = returns.reduce((a,b)=>a+b,0)/returns.length;
    const variance = returns.reduce((a,b)=>a+Math.pow(b-mean,2),0)/returns.length;
    return Math.sqrt(variance);
  }
  static calculateRSI(prices, period=14){
    if (prices.length < period + 1) return 50;
    const changes = [];
    for (let i = prices.length - period; i < prices.length; i++){
      changes.push(prices[i] - prices[i-1]);
    }
    const gains = changes.filter(c=>c>0);
    const losses = changes.filter(c=>c<0).map(c=>Math.abs(c));
    const avgGain = gains.length ? gains.reduce((a,b)=>a+b,0)/period : 0;
    const avgLoss = losses.length ? losses.reduce((a,b)=>a+b,0)/period : 0;
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100/(1+rs));
  }
}

/* =========================
   PREDICTION ENGINE
   RECOMMENDATION:
   - Add momentum8 + momentum12 (more window-aware)
   - Reduce reliance on 3-min
========================= */
class PredictionEngine {
  constructor(){
    this.weights = {
      momentum3:  0.10,
      momentum5:  0.20,
      momentum8:  0.30,
      momentum12: 0.20,
      sma:        0.10,
      rsi:        0.10
    };
  }

  predict(priceHistory){
    if (!priceHistory || priceHistory.length < 25){
      return {
        direction:'FLAT',
        probability:50,
        reasons:[`Insufficient data (${priceHistory?.length||0} candles, need 25+)`],
        indicators:{}
      };
    }

    const prices = priceHistory.map(p=>p.close);

    const momentum3  = Indicators.calculateReturns(prices,3);
    const momentum5  = Indicators.calculateReturns(prices,5);
    const momentum8  = Indicators.calculateReturns(prices,8);
    const momentum12 = Indicators.calculateReturns(prices,12);
    const sma5  = Indicators.calculateSMA(prices,5);
    const sma20 = Indicators.calculateSMA(prices,20);
    const vol   = Indicators.calculateVolatility(prices,20);
    const rsi   = Indicators.calculateRSI(prices,14);

    const signals = {
      momentum3:  momentum3  >= 0 ? 1 : -1,
      momentum5:  momentum5  >= 0 ? 1 : -1,
      momentum8:  momentum8  >= 0 ? 1 : -1,
      momentum12: momentum12 >= 0 ? 1 : -1,
      sma:        sma5 > sma20 ? 1 : -1,
      rsi:        rsi >= 50 ? 1 : -1
    };

    let score = 0;
    score += signals.momentum3  * this.weights.momentum3  * Math.abs(momentum3)  * 100;
    score += signals.momentum5  * this.weights.momentum5  * Math.abs(momentum5)  * 100;
    score += signals.momentum8  * this.weights.momentum8  * Math.abs(momentum8)  * 100;
    score += signals.momentum12 * this.weights.momentum12 * Math.abs(momentum12) * 100;
    score += signals.sma        * this.weights.sma;
    score += signals.rsi        * this.weights.rsi * (Math.abs(rsi-50)/50);

    let direction = 'FLAT';
    if (score > 0.06) direction = 'UP';
    else if (score < -0.06) direction = 'DOWN';

    const probability = Math.min(95, Math.max(50, 50 + Math.abs(score)*45));

    const reasons = [
      `3-min momentum: ${(momentum3*100).toFixed(3)}% (${signals.momentum3>0?'UP':'DOWN'})`,
      `5-min momentum: ${(momentum5*100).toFixed(3)}% (${signals.momentum5>0?'UP':'DOWN'})`,
      `8-min momentum: ${(momentum8*100).toFixed(3)}% (${signals.momentum8>0?'UP':'DOWN'})`,
      `12-min momentum: ${(momentum12*100).toFixed(3)}% (${signals.momentum12>0?'UP':'DOWN'})`,
      `SMA(5)=${sma5.toFixed(2)} vs SMA(20)=${sma20.toFixed(2)} (${signals.sma>0?'UP':'DOWN'})`,
      `RSI(14)=${rsi.toFixed(1)} (${signals.rsi>0?'UP':'DOWN'})`,
      `Volatility: ${(vol*100).toFixed(3)}%`
    ];

    return {
      direction,
      probability: Math.round(probability),
      reasons,
      indicators: {momentum3,momentum5,momentum8,momentum12,sma5,sma20,volatility:vol,rsi,score}
    };
  }
}

/* =========================
   WINDOW MANAGER
   FIX:
   - Only rotate window state in fetchData (not in 1s clock loop)
   - Finalize previous window BEFORE resetting when possible
========================= */
class WindowManager {
  constructor(){
    this.currentWindow = null;
    this.entryPrice = null;
    this.exitPrice = null;
    this.prediction = null;
  }

  update(now){
    const boundaries = TimeUtils.get15MinWindowBoundaries(now);

    if (!this.currentWindow){
      this.currentWindow = boundaries;
      return this.currentWindow;
    }

    if (boundaries.start.getTime() !== this.currentWindow.start.getTime()){
      // finalize previous if complete
      if (this.entryPrice && this.exitPrice && this.prediction){
        this.finalizeWindow();
      } else {
        DebugLogger.add('Window rolled over but missing entry/exit/prediction -> not saved', 'error');
      }

      // reset for new window
      this.currentWindow = boundaries;
      this.entryPrice = null;
      this.exitPrice = null;
      this.prediction = null;

      // reset app-level locks
      if (window.app){
        window.app.finalCall = null;
        window.app.flipCandidate = null;
      }
    }

    return this.currentWindow;
  }

  setEntryPrice(price){
    if (!this.entryPrice && typeof price === 'number'){
      this.entryPrice = price;
      DebugLogger.add(`Entry locked: $${price.toFixed(2)}`);
    }
  }

  setExitPrice(price){
    if (!this.exitPrice && typeof price === 'number'){
      this.exitPrice = price;
      DebugLogger.add(`Exit locked: $${price.toFixed(2)}`);
    }
  }

  setPrediction(prediction){ this.prediction = prediction; }

  finalizeWindow(){
    if (!this.currentWindow || !this.entryPrice || !this.exitPrice || !this.prediction) return;

    let actualDirection = 'FLAT';
    if (this.exitPrice > this.entryPrice) actualDirection = 'UP';
    else if (this.exitPrice < this.entryPrice) actualDirection = 'DOWN';

    const correct = actualDirection === this.prediction.direction;

    app.storage.addWindow({
      windowStartET: this.currentWindow.start.getTime(),
      windowEndET: this.currentWindow.end.getTime(),
      entryPrice: this.entryPrice,
      exitPrice: this.exitPrice,
      predictedDirection: this.prediction.direction,
      predictedProbability: this.prediction.probability,
      actualDirection,
      correct,
      timestampCreated: Date.now(),
      timestampClosed: Date.now(),
      indicators: this.prediction.indicators
    });

    DebugLogger.add(`Window finalized: ${correct?'‚úì':'‚úó'} Pred ${this.prediction.direction} | Actual ${actualDirection}`);

    if (window.app && typeof window.app.renderHistory === 'function'){
      window.app.renderHistory();
    }
  }

  getTimeUntilEnd(){
    if (!this.currentWindow) return 0;
    const now = TimeUtils.getNowET();
    const diff = Math.floor((this.currentWindow.end - now) / 1000);
    return Math.max(0, diff);
  }
}

/* =========================
   STORAGE
========================= */
class Storage {
  constructor(){
    this.SCHEMA_VERSION = 1;
    this.MAX_WINDOWS = 500;
    this.KEY = 'btc_guesser_history';
  }

  load(){
    try{
      const data = localStorage.getItem(this.KEY);
      if (!data) return [];
      const parsed = JSON.parse(data);
      if (parsed.version !== this.SCHEMA_VERSION) return [];
      return parsed.windows || [];
    } catch {
      return [];
    }
  }

  save(windows){
    try{
      localStorage.setItem(this.KEY, JSON.stringify({
        version: this.SCHEMA_VERSION,
        windows: windows.slice(-this.MAX_WINDOWS)
      }));
    } catch {}
  }

  addWindow(window){
    const windows = this.load();
    windows.push(window);
    this.save(windows);
  }

  clear(){ localStorage.removeItem(this.KEY); }
  export(){ return this.load(); }
  import(windows){ this.save(windows); }
}

/* =========================
   CHART RENDERER
========================= */
class ChartRenderer {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.padding = {top:20,right:50,bottom:30,left:10};
  }

  render(priceHistory){
    if (!priceHistory || priceHistory.length === 0) return;

    const rect = this.canvas.getBoundingClientRect();
    this.canvas.width = rect.width;
    this.canvas.height = rect.height;

    const {ctx, padding} = this;
    const width = this.canvas.width;
    const height = this.canvas.height;

    ctx.fillStyle = '#0f1729';
    ctx.fillRect(0,0,width,height);

    const prices = priceHistory.map(p=>p.close);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const range = (maxPrice - minPrice) || 1;

    const chartW = width - padding.left - padding.right;
    const chartH = height - padding.top - padding.bottom;

    ctx.strokeStyle = '#2a3f5f';
    ctx.lineWidth = 1;
    for (let i=0;i<=4;i++){
      const y = padding.top + (chartH/4)*i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();

      const price = maxPrice - (range/4)*i;
      ctx.fillStyle = '#888';
      ctx.font = '11px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(price.toFixed(0), width - padding.right + 5, y + 4);
    }

    ctx.strokeStyle = '#4a9eff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    priceHistory.forEach((pt, idx) => {
      const x = padding.left + (chartW/(priceHistory.length-1))*idx;
      const y = padding.top + chartH - ((pt.close - minPrice)/range)*chartH;
      if (idx===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    const last = priceHistory[priceHistory.length-1]?.close;
    const y = padding.top + chartH - ((last - minPrice)/range)*chartH;
    ctx.fillStyle = '#51cf66';
    ctx.beginPath();
    ctx.arc(width - padding.right, y, 4, 0, Math.PI*2);
    ctx.fill();
  }
}

/* =========================
   MAIN APP
========================= */
class App {
  constructor(){
    this.storage = new Storage();
    this.aggregator = new PriceAggregator();
    this.predictor = new PredictionEngine();
    this.windowManager = new WindowManager();
    this.chartRenderer = new ChartRenderer(document.getElementById('priceChart'));

    this.priceHistory = [];
    this.fetchInterval = 12000;

    // ‚úÖ stability / recommendation states
    this.finalCall = null;       // locked around T-8..T-7
    this.flipCandidate = null;   // 2-step confirmation tracker

    this.init();
  }

  async init(){
    DebugLogger.add('App initializing...');
    this.updateTime();
    setInterval(()=>this.updateTime(), 1000);

    await this.fetchData();
    setInterval(()=>this.fetchData(), this.fetchInterval);

    this.renderHistory();
  }

  // display-only (no window state mutation here)
  updateTime(){
    const now = TimeUtils.getNowET();
    document.getElementById('currentTime').textContent = TimeUtils.formatET(now, 'time');

    const boundaries = TimeUtils.get15MinWindowBoundaries(now);
    document.getElementById('windowStart').textContent = TimeUtils.formatET(boundaries.start, 'time');
    document.getElementById('windowEnd').textContent = TimeUtils.formatET(boundaries.end, 'time');

    const diff = Math.max(0, Math.floor((boundaries.end - now) / 1000));
    document.getElementById('countdown').textContent = TimeUtils.formatCountdown(diff);
  }

  // ‚úÖ Strong suggestion (conviction)
  getTradeSuggestion(prediction, providerConfidence){
    const timeLeft = this.windowManager.getTimeUntilEnd();
    const ind = prediction.indicators || {};

    let conviction = (prediction.probability - 50) * 2; // 0..90

    if (providerConfidence === 'LOW') conviction -= 12;
    if (providerConfidence === 'NO_DATA') conviction -= 30;

    const vol = (ind.volatility ?? 0);
    if (vol > 0.0015) conviction -= 8;
    if (vol > 0.0030) conviction -= 15;

    const m5  = ind.momentum5 ?? 0;
    const m12 = ind.momentum12 ?? 0;
    const aligned = (m5 >= 0 && m12 >= 0) || (m5 < 0 && m12 < 0);
    if (aligned) conviction += 6;
    else conviction -= 6;

    const inLast2Min = timeLeft <= 120;
    if (inLast2Min && prediction.probability >= 72 && aligned) conviction += 6;

    conviction = Math.max(0, Math.min(100, Math.round(conviction)));

    let action = 'NO TRADE';
    if (providerConfidence !== 'NO_DATA'){
      if (prediction.direction === 'UP' && prediction.probability >= 65) action = 'LONG';
      if (prediction.direction === 'DOWN' && prediction.probability >= 65) action = 'SHORT';
    }

    let strength = 'WEAK';
    if (conviction >= 70) strength = 'STRONG';
    else if (conviction >= 55) strength = 'MEDIUM';

    const notes = [];
    notes.push(`Conviction: ${conviction}/100 (${strength})`);
    notes.push(`Time left: ${TimeUtils.formatCountdown(timeLeft)}`);
    notes.push(`Provider confidence: ${providerConfidence}`);
    if (vol) notes.push(`Volatility: ${(vol*100).toFixed(3)}%`);
    notes.push(`Momentum alignment (5m & 12m): ${aligned ? 'YES' : 'NO'}`);
    if (inLast2Min && prediction.probability < 65) notes.push('Late window: signal not strong enough');

    return { action, conviction, strength, notes };
  }

  // ‚úÖ Recommendation: lock FINAL CALL around T-8..T-7
  maybeLockFinalCall(prediction, confidence){
    const win = this.windowManager.currentWindow;
    if (!win) return;

    const timeLeft = this.windowManager.getTimeUntilEnd(); // seconds
    const LOCK_FROM = 8 * 60; // T-8
    const LOCK_TO   = 7 * 60; // T-7 (small range so 12s polling won't miss)

    if (this.finalCall && this.finalCall.windowEndMs === win.end.getTime()) return;

    if (timeLeft <= LOCK_FROM && timeLeft >= LOCK_TO){
      this.finalCall = {
        windowEndMs: win.end.getTime(),
        dir: prediction.direction,
        prob: prediction.probability,
        lockedAtMs: Date.now(),
        confidence
      };
      this.flipCandidate = null;
      DebugLogger.add(`FINAL CALL locked: ${this.finalCall.dir} (${this.finalCall.prob}%)`);
    }
  }

  // ‚úÖ Allow flip only with:
  // - major change (>=78% OR beats finalCall by +12%)
  // - 2-step confirmation (2 consecutive fetch cycles)
  applyFinalCallFlipRules(livePrediction){
    const win = this.windowManager.currentWindow;
    if (!win || !this.finalCall || this.finalCall.windowEndMs !== win.end.getTime()){
      return livePrediction;
    }

    const baseDir = this.finalCall.dir;
    const baseProb = this.finalCall.prob;

    // same as base: keep base direction (optionally bump prob up)
    if (livePrediction.direction === baseDir){
      this.flipCandidate = null;
      const bumped = Math.max(baseProb, Math.min(95, livePrediction.probability));
      return { ...livePrediction, direction: baseDir, probability: bumped };
    }

    // candidate flip
    const candidateDir = livePrediction.direction;

    const STRONG_PROB = 78;
    const BEAT_MARGIN = 12;
    const isMajor = (livePrediction.probability >= STRONG_PROB) ||
                    (livePrediction.probability >= baseProb + BEAT_MARGIN);

    if (!isMajor){
      return { ...livePrediction, direction: baseDir, probability: baseProb };
    }

    // 2-step confirmation
    if (!this.flipCandidate || this.flipCandidate.dir !== candidateDir){
      this.flipCandidate = { dir: candidateDir, count: 1, bestProb: livePrediction.probability };
      return { ...livePrediction, direction: baseDir, probability: baseProb };
    }

    this.flipCandidate.count += 1;
    this.flipCandidate.bestProb = Math.max(this.flipCandidate.bestProb, livePrediction.probability);

    if (this.flipCandidate.count >= 2){
      this.finalCall.dir = candidateDir;
      this.finalCall.prob = Math.max(this.finalCall.prob, this.flipCandidate.bestProb);
      this.flipCandidate = null;
      DebugLogger.add(`FINAL CALL flipped (confirmed): ${this.finalCall.dir} (${this.finalCall.prob}%)`);
      return { ...livePrediction, direction: this.finalCall.dir, probability: this.finalCall.prob };
    }

    return { ...livePrediction, direction: baseDir, probability: baseProb };
  }

  renderFinalCall(){
    const box = document.getElementById('finalCallBox');
    if (!box) return;

    if (!this.finalCall){
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const lockedTime = new Date(this.finalCall.lockedAtMs).toLocaleTimeString();
    box.style.display = 'inline-block';
    box.innerHTML = `
      <div style="font-weight:1000;">FINAL CALL: ${this.finalCall.dir} ‚Ä¢ ${this.finalCall.prob}%</div>
      <div style="margin-top:6px;font-weight:800;font-size:11px;line-height:1.35;text-align:left;">
        ‚Ä¢ Locked time: ${lockedTime}<br>
        ‚Ä¢ Lock zone: T-8..T-7<br>
        ‚Ä¢ Flip rule: major change + 2-step confirm<br>
        ‚Ä¢ Provider confidence: ${this.finalCall.confidence}
      </div>
    `;
  }

  async fetchData(){
    const now = TimeUtils.getNowET();

    // ‚úÖ update window state only when fetching (so finalize has data)
    const win = this.windowManager.update(now);
    if (!win) return;

    try{
      const {referencePrice, providerData, confidence} = await this.aggregator.fetchAllPrices();
      this.renderProviderTable(providerData, referencePrice, confidence);

      if (!referencePrice){
        document.getElementById('predictionDirection').textContent = 'NO DATA';
        document.getElementById('predictionProbability').textContent = '---%';
        document.getElementById('predictionReasons').innerHTML = '<li>No providers available</li>';
        document.getElementById('tradeSuggestion').style.display = 'none';
        this.renderFinalCall();
        return;
      }

      const lookbackMs = 90*60*1000;
      const startTime = now.getTime() - lookbackMs;
      const endTime = now.getTime();

      const candles = await this.aggregator.fetchCandles(startTime, endTime);

      if (!candles || candles.length === 0){
        document.getElementById('predictionWarning').innerHTML =
          '<div class="warning">‚ö†Ô∏è Waiting for historical data (candles)...</div>';

        this.priceHistory = [{timestamp: now.getTime(), close: referencePrice}];
        this.chartRenderer.render(this.priceHistory);
        this.renderFinalCall();
        return;
      }

      this.priceHistory = candles;
      document.getElementById('predictionWarning').innerHTML = '';

      // entry lock once window started
      if (now >= win.start && !this.windowManager.entryPrice){
        const entryCandle = candles.find(c => c.timestamp >= win.start.getTime());
        this.windowManager.setEntryPrice(entryCandle ? entryCandle.close : candles[candles.length-1].close);
      }

      // prediction
      let prediction = this.predictor.predict(this.priceHistory);

      // lock final call around T-8..T-7
      this.maybeLockFinalCall(prediction, confidence);

      // after final call exists: apply flip rules (2-step + major change)
      prediction = this.applyFinalCallFlipRules(prediction);

      this.windowManager.setPrediction(prediction);

      // lock exit + finalize when window ended (even if "late")
      if (now >= win.end && !this.windowManager.exitPrice){
        this.windowManager.setExitPrice(referencePrice);
        if (this.windowManager.entryPrice && this.windowManager.prediction){
          this.windowManager.finalizeWindow();
        }
      }

      this.renderPrediction(prediction, confidence);
      this.renderFinalCall();
      this.chartRenderer.render(this.priceHistory);
      this.updateStats();
      this.renderHistory();
    } catch (err){
      DebugLogger.add(`Fetch error: ${err.message}`, 'error');
      document.getElementById('predictionWarning').innerHTML = `<div class="warning">‚ö†Ô∏è Error: ${err.message}</div>`;
    }
  }

  renderProviderTable(providerData, referencePrice, confidence){
    const tbody = document.getElementById('providerTableBody');
    tbody.innerHTML = providerData.map(pd => `
      <tr>
        <td><strong>${pd.name}</strong></td>
        <td>${pd.price !== null ? '$' + pd.price.toFixed(2) : '-'}</td>
        <td>${pd.latency !== null ? pd.latency + 'ms' : '-'}</td>
        <td><span class="provider-status ${pd.status}">${pd.status.toUpperCase()}</span></td>
      </tr>
    `).join('');

    const cdiv = document.getElementById('confidenceWarning');
    if (confidence === 'LOW'){
      cdiv.innerHTML = '<div class="confidence-warning">‚ö†Ô∏è LOW CONFIDENCE - Only 1 provider included</div>';
    } else if (confidence === 'NO_DATA'){
      cdiv.innerHTML = '<div class="confidence-warning">‚ùå NO DATA - All providers failed</div>';
    } else {
      cdiv.innerHTML = '';
    }

    if (referencePrice){
      cdiv.innerHTML += `<div style="margin-top:10px;color:#51cf66;font-weight:900;">Reference Price: $${referencePrice.toFixed(2)}</div>`;
    }
  }

  renderPrediction(prediction, confidence){
    const dirEl = document.getElementById('predictionDirection');
    const probEl = document.getElementById('predictionProbability');
    const whyEl = document.getElementById('predictionReasons');

    dirEl.textContent = prediction.direction;
    dirEl.className = 'prediction-direction ' + prediction.direction;
    probEl.textContent = prediction.probability + '%';
    whyEl.innerHTML = prediction.reasons.map(r => `<li>${r}</li>`).join('');

    if (confidence !== 'HIGH'){
      document.getElementById('predictionWarning').innerHTML =
        `<div class="warning">‚ö†Ô∏è Price confidence: ${confidence}. Prediction may be less reliable.</div>`;
    }

    // ‚úÖ Strong suggestion render
    const box = document.getElementById('tradeSuggestion');
    const sug = this.getTradeSuggestion(prediction, confidence);
    box.style.display = 'inline-block';
    box.innerHTML = `
      <div style="font-weight:1000;">Suggestion: ${sug.action} ‚Ä¢ ${sug.strength}</div>
      <div style="margin-top:6px;font-weight:800;font-size:11px;line-height:1.35;text-align:left;">
        ${sug.notes.map(n => `‚Ä¢ ${n}`).join('<br>')}
      </div>
    `;
  }

  updateStats(){
    const history = this.storage.load();
    const total = history.length;
    const correct = history.filter(w => w.correct).length;
    const accuracy = total > 0 ? ((correct/total)*100).toFixed(1) : '0.0';

    document.getElementById('totalWindows').textContent = total;
    document.getElementById('correctCount').textContent = correct;
    document.getElementById('accuracy').textContent = accuracy + '%';
  }

  renderHistory(){
    const history = this.storage.load();
    const tbody = document.getElementById('historyTableBody');

    if (history.length === 0){
      tbody.innerHTML = '<tr><td colspan="7">No history yet</td></tr>';
      this.updateStats();
      return;
    }

    const sorted = [...history].sort((a,b)=>b.timestampCreated - a.timestampCreated);
    tbody.innerHTML = sorted.map(w => {
      const startTime = TimeUtils.formatET(new Date(w.windowStartET), 'time');
      const endTime = TimeUtils.formatET(new Date(w.windowEndET), 'time');

      let correctMark = '<span class="correct-mark pending">?</span>';
      if (w.actualDirection){
        correctMark = w.correct
          ? '<span class="correct-mark yes">‚úì</span>'
          : '<span class="correct-mark no">‚úó</span>';
      }

      return `
        <tr>
          <td>${new Date(w.timestampCreated).toLocaleString()}</td>
          <td>${startTime} - ${endTime}</td>
          <td><strong>${w.predictedDirection}</strong> (${w.predictedProbability}%)</td>
          <td><strong>${w.actualDirection || 'PENDING'}</strong></td>
          <td>$${w.entryPrice ? w.entryPrice.toFixed(2) : '-'}</td>
          <td>$${w.exitPrice ? w.exitPrice.toFixed(2) : '-'}</td>
          <td>${correctMark}</td>
        </tr>
      `;
    }).join('');

    this.updateStats();
  }

  exportHistory(){
    const history = this.storage.export();
    const blob = new Blob([JSON.stringify(history,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `btc-guesser-history-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  importHistory(event){
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try{
        const data = JSON.parse(e.target.result);
        this.storage.import(data);
        this.renderHistory();
        alert('History imported successfully!');
      } catch (err){
        alert('Failed to import history: ' + err.message);
      }
    };
    reader.readAsText(file);
  }

  clearHistory(){
    if (confirm('Are you sure you want to clear all history? This cannot be undone.')){
      this.storage.clear();
      this.renderHistory();
    }
  }

  sortHistory(){ this.renderHistory(); }
}

let app;
window.addEventListener('DOMContentLoaded', () => {
  app = new App();
  window.app = app;
});
</script>
</body>
</html>